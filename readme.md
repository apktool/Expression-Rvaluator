# 虚析构函数

虚基类中，基类指针指向派生类对象，如果析构函数不声明为虚函数的话，会导致通过基类指针释放派生类对象时出错。
 比如：
```c
Node* p=new AddNode
 delete p;
```
 如果不使用虚析构函数的话，会导致AddNode类中的析构函数没办法执行。
 即只会执行基类的析构函数，而不会执行派生类的析构函数

# 值语义与对象语义
## 值语义
值语义是指对象的拷贝与原对象无关。拷贝之后就与原对象脱离关系，彼此独立互不影响。
值语义对象：string, vector, map
一个类只有实现了深拷贝之后才算是值语义

## 对象语义
对象语义指的是面向对象意义下的对象

+ 对象拷贝是禁止的
+ 一个对象被系统标准的复制方式复制后，与被复制的对象之间依然共享底层资源，对任何一个的改变都将改变另一个

## 值语义与对象语义的区别
值语义对象声明周期容易控制；对象语义不容易控制（通过智能指针来解决，智能指针实际上是将对象语义转化为值语义）
值语义与对象语义是分析模型决定的，语言的语法技巧用来匹配模型

面向对象编程	值语义
基于对象编程	对象语义

值语义对象通常以类对象的方式来使用
对象语义通常以指针或者引用方式来使用

智能指针
auto_ptr	所有权（指针所指向的资源）独占，不能共享，但是可以转移
shared_ptr	所有权共享，内部维护了一个引用计数
weak_ptr	弱指针，通常需要与shared_ptr配合使用，一般为了解决循环应用的问题
scoped_ptr 	与auto_ptr类似，所有权独占，不能共享，但是也不可以转移

# 接口继承和实现继承
## 接口继承：
基类的公有成员函数在派生类中仍然是公有的，话句话说是基类的接口成为了派生类的接口，因而将它称为接口继承

## 实现继承；
对于私有、保护继承会导致基类的公有成员函数在派生类不再保持公有的属性，派生类将不再支持基类的公有接口，它希望能重用基类的实现而已，因此将它称为实现继承。

# 表达式解析

逆波兰表示法	栈	数据结构
递归下降法		树	编译原理	语法树	表达式树

+ expression:=					表达式
	- term '+' expression		一个后面有加号或减号的项，加号或减号的后面又是另一个表达式
	- term '-' expression		表达式也可以为一个项加一个等于号，再加一个表达式
	- term						如果表达式不含任何加号或减号，它等于此项
+ term:=						项
	- factor '*' term			被另一个项乘或除的因子
	- factor '/' term
	- factor					如果一个项不包含任何乘或除运算符，它等于此因子
+ factor						因子
	- number					一个因子可以是一个数字
	- identifier				一个对应于某变量的标识符
	- '-'factor					后面带有一个因子的减号
	- '('expression')'			小括号中的整个表达式

# 资源所有权

一个代码块拥有在其作用域内定义的所有自动对象。释放这些资源的任务是自动的（调用析构函数）
所有权的另一种形式是嵌入。一个对象拥有所有嵌入其中的对象。释放这些资源的任务也是自动完成（外部对象的析构函数调用内部对象的析构函数）
资源的生存期为嵌入实体的生存期。
对于动态分配对象就不是这样了，它总是通过指针访问，在它们的生存期内，指针可以指向一个资源序列，若干指针可以指向相同的资源。动态分配资源的释放不是自动完成的。
如果对象从一个指针传递到另一个指针，所有权关系就不容易跟踪。空悬指针，内存泄露，重复删除

# RAII(Resource Acquisition Is Initialization)
一个对象可以拥有资源。在对象的构造函数中执行资源的获取（指针的初始化），在析构函数中释放。

# vector
vector 保存的是指针本身，并没有保存指针所指向的内存
vector 不负责指针所指向的内存的管理
vector 中不能存放auto_ptr；如果有必要可以存放shared_ptr, scoped_ptr

STL容器要求存放在容器中的元素能够被拷贝，也就是要求类型是值语义对象

# 序列化和反序列化
将对象保存到文件中，称为序列化
从文件中取出数据保存到对象中，称为反序列化

# 对于不同类型的相同操作
## 宏替换
不做类型检查

## 重载
为每个类型提供一个重载版本，程序自己来维护这些重载的版本

## 模板
为相同的逻辑功能提供一个模板，将类型当作参数来传递，让编译器实例化对应版本的函数来处理。不同的版本有编译器来维护

# 模板

- 模板是一种参数化的多态工具；
- 所谓参数化的多态性，是指将程序所处理的对象的类型参数化，使一段程序代码可以处理多种不同类型的对象；
- 采用模板编程，可以为各种逻辑功能相同而数据类型不同的程序提供一种代码共享机制

模板主要分为两类，函数模板和类模板

为了运行的效率，类模板是相互独立的，即独立设计，没有使用继承的思想。对类模板的扩展是采用适配器来完成的。通用性是模板的设计出发点之一，这是由泛型算法和函数对象等手段达到的

派生的目标之一是代码的复用和程序的通用性，派生类的优点是可以由简到繁，逐步深入，程序编制过程中可以充分利用前面的工作，一步步的完成一个复杂的任务

# 泛型程序设计(generic programming)

- 将程序写的尽可能通用
- 将算法从数据结构中抽象出来，成为通用的
- C++的模板为泛型程序设计奠定了关键的基础

# STL(Standard Template Library)
标准模板库，是一个高效的C++程序库
- 从逻辑层次上来看，在STL中体现了泛型化程序设计的思想(generic programming)
- 从实现层次上来看，整个STL是以一种类型参数化的方式实现的(type parameterized)，基于模板

# 六大组件
Container[容器]:各种基本数据结构
Iterator[迭代器]:连接containers和algorithms
Algorithm[算法]:各种基本算法，如sort、search...
Adapter[适配器]:可以改变Containers、Iterators或Function object接口的一种组件
Function object[函数对象]:
Allocator[分配器]:

## 容器
容器类是容纳、包含一组元素或元素集合的对象
可以分为两类

- 序列式容器:Sequence containers|vector,deque,list

每个元素均由固定位置，取决于插入时间和地点

- 关联式容器:Associative containers|set,multiset,map,multimap

元素位置取决与特定的排序准则以及元素值，和插入的次序无关

vector容器	值语义
向容器中插入指针，容器拷贝的仅仅只是指针，容器并不负责所指向的内存空间的释放
网容器中插入类对象，容器拷贝整个对象（即容器中拷贝的对象与原对象脱离关系）

### 七种基本容器
vector[向量]:内部空间连续，只能在其一端操作
deque[双端队列]:内部空间不完全连续，可以在两端操作
list[列表]:实际为双向链表，可以在两端操作
set[集合]:仅存储关键字
multiset[多重集合]:
map[映射]:基于关键字和值存储
multimap[多重映射]

## 迭代器

用来在一个对象群集的元素上进行遍历。这个对象群集或许是个容器，或许是容器的一部分。迭代器的主要好处是，为所有容器提供了一组很小的公共接口。迭代器是以++进行累进，以*进行提领，因而它类似与指针，我们可以将它视为一种smart pointer

模板为泛型程序设计奠定了基础，STL体现了泛型程序设计思想；换句话说，STL是泛型程序设计思想比较成功的一套产品

迭代器是泛型指针

- 普通指针可以指向内存中的一个地址
- 迭代器可以指向容器中的一个位置

STL的每一个容器类模板中，都定义了一组对应的迭代器类。使用迭代器，算法函数可以访问容器中指定位置的元素，而无需关心元素的具体类型

### 迭代器类型

- 输入迭代器：可以用来从序列中读取数据
- 输出迭代器：允许向序列中写入数据
- 前向迭代器：既是输入迭代器又是输出迭代器，并且可以对序列进行单向遍历
- 双向迭代器：与前向迭代器相似，但是在两个方向上都可以进行数据遍历
- 随机访问迭代器：也是双向迭代器，但能够在序列中的任何两个位置之间跳转

## 算法

算法是以函数模板的形式实现的。常用的算法涉及到比较、交换、查找、搜索、复制、修改、移除、反转、排序、合并等等。
算法并非容器类型的成员函数，而是一些全局函数，要与迭代器一起搭配使用。
算法的优势在于只需实现一份，可以适应所有容器，不必为每一种容器量身定制，也可以与用户定义的容器搭配

### 算法的分类

- 非变动算法：既不改变元素次序，也不改变元素值
- 变动性算法：要么直接改变元素值，要么就是在复制到另一个区间的过程中改变元素的值
- 移除性算法：是一种特殊的变动性算法
- 变序性算法：改变元素次序，但不改变元素值
- 排序算法：是一种特殊的变序算法
- 已序区间算法
- 用来处理数值的算法

## 适配器

为已有的类提供新的接口，目的是简化，约束，使之安全，隐藏或者改变被修改类提供的服务集合

### 三种适配器

- 容器适配器：用来扩展七种基本容器，它们和顺序容器相结合构成栈，队列和优先队列容器
- 迭代器适配器：反向迭代器，插入迭代器，IO流迭代器
- 函数适配器：函数对象适配器，成员函数适配器，普通函数适配器

## 函数对象

函数对象也称为仿函数
一个行为类似函数的对象，它可以没有参数，也可以带有若干参数；
任何重载了调用运算符operator()的类对象都满足函数对象的特征；
函数对象可以把它称之为smart function
STL中也定义了一些标准的函数对象，如果以功能划分，可以分为算数运算，关系运算，逻辑运算三大类。为了调用这些标准函数对象，需要包含头文件<functional>
