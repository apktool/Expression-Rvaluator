# 虚析构函数

虚基类中，基类指针指向派生类对象，如果析构函数不声明为虚函数的话，会导致通过基类指针释放派生类对象时出错。
 比如：
```c
Node* p=new AddNode
 delete p;
```
 如果不使用虚析构函数的话，会导致AddNode类中的析构函数没办法执行。
 即只会执行基类的析构函数，而不会执行派生类的析构函数

# 值语义与对象语义
## 值语义
值语义是指对象的拷贝与原对象无关。拷贝之后就与原对象脱离关系，彼此独立互不影响。
值语义对象：string, vector, map
一个类只有实现了深拷贝之后才算是值语义

## 对象语义
对象语义指的是面向对象意义下的对象

+ 对象拷贝是禁止的
+ 一个对象被系统标准的复制方式复制后，与被复制的对象之间依然共享底层资源，对任何一个的改变都将改变另一个

## 值语义与对象语义的区别
值语义对象声明周期容易控制；对象语义不容易控制（通过智能指针来解决，智能指针实际上是将对象语义转化为值语义）
值语义与对象语义是分析模型决定的，语言的语法技巧用来匹配模型

面向对象编程	值语义
基于对象编程	对象语义

值语义对象通常以类对象的方式来使用
对象语义通常以指针或者引用方式来使用

智能指针
auto_ptr	所有权（指针所指向的资源）独占，不能共享，但是可以转移
shared_ptr	所有权共享，内部维护了一个引用计数
weak_ptr	弱指针，通常需要与shared_ptr配合使用，一般为了解决循环应用的问题
scoped_ptr 	与auto_ptr类似，所有权独占，不能共享，但是也不可以转移

# 接口继承和实现继承
## 接口继承：
基类的公有成员函数在派生类中仍然是公有的，话句话说是基类的接口成为了派生类的接口，因而将它称为接口继承

## 实现继承；
对于私有、保护继承会导致基类的公有成员函数在派生类不再保持公有的属性，派生类将不再支持基类的公有接口，它希望能重用基类的实现而已，因此将它称为实现继承。

# 表达式解析

逆波兰表示法	栈	数据结构
递归下降法		树	编译原理	语法树	表达式树

+ expression:=					表达式
	- term '+' expression		一个后面有加号或减号的项，加号或减号的后面又是另一个表达式
	- term '-' expression		表达式也可以为一个项加一个等于号，再加一个表达式
	- term						如果表达式不含任何加号或减号，它等于此项
+ term:=						项
	- factor '*' term			被另一个项乘或除的因子
	- factor '/' term
	- factor					如果一个项不包含任何乘或除运算符，它等于此因子
+ factor						因子
	- number					一个因子可以是一个数字
	- identifier				一个对应于某变量的标识符
	- '-'factor					后面带有一个因子的减号
	- '('expression')'			小括号中的整个表达式

# 资源所有权

一个代码块拥有在其作用域内定义的所有自动对象。释放这些资源的任务是自动的（调用析构函数）
所有权的另一种形式是嵌入。一个对象拥有所有嵌入其中的对象。释放这些资源的任务也是自动完成（外部对象的析构函数调用内部对象的析构函数）
资源的生存期为嵌入实体的生存期。
对于动态分配对象就不是这样了，它总是通过指针访问，在它们的生存期内，指针可以指向一个资源序列，若干指针可以指向相同的资源。动态分配资源的释放不是自动完成的。
如果对象从一个指针传递到另一个指针，所有权关系就不容易跟踪。空悬指针，内存泄露，重复删除

# RAII(Resource Acquisition Is Initialization)
一个对象可以拥有资源。在对象的构造函数中执行资源的获取（指针的初始化），在析构函数中释放。

# vector
vector 保存的是指针本身，并没有保存指针所指向的内存
vector 不负责指针所指向的内存的管理
vector 中不能存放auto_ptr；如果有必要可以存放shared_ptr, scoped_ptr

STL容器要求存放在容器中的元素能够被拷贝，也就是要求类型是值语义对象

# 序列化和反序列化
将对象保存到文件中，称为序列化
从文件中取出数据保存到对象中，称为反序列化
